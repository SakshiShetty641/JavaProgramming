JSHELL
-> JShell is a Read-Eval-Print Loop (REPL)
-> JShell is particularly useful for learning Java, experimenting with new features, and testing code snippets before incorporating them into larger projects.
 It provides a lightweight and interactive environment for Java developers to explore and prototype code.

 -> jhell -> To enter jshell
 -> /exit -> To exit



 Precedence

 % * / has greater precedence than  + -


 -> The eight primitives defined in Java are int, byte, short, long, float, double, boolean and char.

 Main method
-> public: This keyword indicates that the main method can be accessed from anywhere. It has the most accessible level of visibility.
-> static: The main method is declared as static so that it can be called without creating an instance of the class. This means it belongs to the class itself rather than to any instance of the class.
-> void: The main method returns void, which means it does not return any value.
-> main: This is the name of the method. It is the standard name recognized by the JVM as the entry point of the program.
 String[] args: This parameter allows the main method to accept command-line arguments as an array of strings. When you run a Java program from the command line, you can pass arguments to it. These arguments are stored in the args array.


 JVM is the runtime environment that executes Java bytecode.
 JRE is a package that includes the JVM and necessary runtime libraries for running Java applications.
 JDK is a development kit that includes the JRE, development tools, and additional libraries for Java application development.

Naming Convention
Snake Case: In snake case, all letters are lowercase, and words are separated by underscores. For example: my_variable_name, this_is_snake_case.
Pascal Case: In Pascal case, also known as Upper Camel case, the first letter of each word is capitalized and there are no spaces. For example: MyVariableName, ThisIsPascalCase.
Camel Case: Camel case, or Lower Camel case, is similar to Pascal case, but the first word starts with a lowercase letter. Subsequent words start with uppercase letters. For example: myVariableName, thisIsCamelCase.



Stack and Heap
-> the stack is used for managing method invocation and local variables in Java,
while the heap is used for storing objects dynamically allocated during runtime.
-> The stack is responsible for storing method invocations, local variables, and partial results.
-> Objects created in Java are stored in the heap.


Reference variables
-> In Java, a reference variable is a variable that holds the memory address (reference) of an object rather than the actual object itself.
->Unlike primitive variables, which hold the actual values, reference variables point to objects in memory.
-> StringBuilder and StringBuffer classes are used to manipulate strings.

-> ArrayList when you need fast random access and traversal, and LinkedList
when you need efficient insertion and deletion operations at arbitrary positions within the list.





Equals and Hashcode method
->
In Java, equals() and hashCode() are two important methods defined in the Object class, which is the root class for all Java classes. They are often overridden in user-defined classes to provide customized behavior for equality comparison and hash code generation.

equals(Object obj):
This method is used to compare the equality of two objects.
It takes an Object as a parameter and returns a boolean value indicating whether the objects are equal or not.
The default implementation in the Object class checks for reference equality, meaning it returns true if and only if the two object references point to the same memory location.
However, in most cases, you need to override this method to define a custom equality comparison based on the contents or attributes of the objects.

hashCode():
This method is used to generate a hash code value for an object.
It returns an int value representing the hash code of the object.
The default implementation in the Object class returns a memory address-based hash code (the internal memory address of the object in hexadecimal form).
It's important to override hashCode() when you override equals(), as per the contract between these two methods: if two objects are equal according to the equals(Object obj) method, then calling hashCode() on each of the two objects must return the same integer result.


Links
-> https://norvig.com/21-days.html

